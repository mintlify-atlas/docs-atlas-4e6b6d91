---
title: Quickstart
description: Build your first message queue producer and consumer with Broccoli
---

## Overview

This guide will walk you through creating a simple producer-consumer system using Broccoli. You'll learn how to:

- Define a message payload structure
- Publish messages to a queue
- Consume and process messages
- Handle errors and retries

<Note>
  Make sure you've completed the [installation](/installation) and have a Redis instance running on `localhost:6379`.
</Note>

## Define your message type

First, define the structure of your messages using Serde:

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}
```

<Note>
  Your message types must implement `Clone`, `Serialize`, and `Deserialize` traits.
</Note>

## Create a producer

The producer publishes messages to a queue. Here's a complete example:

```rust
use broccoli_queue::queue::BroccoliQueue;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the queue
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    // Create jobs to publish
    let jobs = vec![
        JobPayload {
            id: "job-1".to_string(),
            task_name: "process_data".to_string(),
        },
        JobPayload {
            id: "job-2".to_string(),
            task_name: "generate_report".to_string(),
        },
    ];

    // Publish jobs in batch
    queue.publish_batch("jobs", None, jobs, None).await?;

    println!("Published jobs successfully!");
    Ok(())
}
```

<Steps>
  <Step title="Initialize the queue">
    Create a `BroccoliQueue` instance with your broker URL:
    ```rust
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;
    ```
  </Step>
  <Step title="Create your messages">
    Instantiate your message payloads:
    ```rust
    let jobs = vec![
        JobPayload {
            id: "job-1".to_string(),
            task_name: "process_data".to_string(),
        },
    ];
    ```
  </Step>
  <Step title="Publish to the queue">
    Use `publish_batch` to send multiple messages at once:
    ```rust
    queue.publish_batch("jobs", None, jobs, None).await?;
    ```
  </Step>
</Steps>

## Create a consumer

The consumer processes messages from the queue. Here's a complete example:

```rust
use broccoli_queue::{error::BroccoliError, queue::BroccoliQueue};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the queue
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    // Process messages with 2 concurrent workers
    queue
        .process_messages(
            "jobs",
            Some(2),
            None,
            |message| async move {
                println!("Processing job: {:?}", message.payload);
                
                // Simulate some work
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                
                Ok(())
            },
        )
        .await?;

    Ok(())
}
```

<Steps>
  <Step title="Initialize the queue">
    Create a `BroccoliQueue` instance with the same configuration as your producer:
    ```rust
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;
    ```
  </Step>
  <Step title="Process messages">
    Call `process_messages` with your handler function:
    ```rust
    queue.process_messages(
        "jobs",      // Queue name
        Some(2),     // Number of concurrent workers
        None,        // Consume options
        |message| async move {
            // Your message processing logic
            println!("Processing: {:?}", message.payload);
            Ok(())
        },
    ).await?;
    ```
  </Step>
</Steps>

## Understanding the flow

Here's what happens when you run both the producer and consumer:

1. **Producer** publishes messages to the `jobs` queue
2. **Consumer** pulls messages from the queue
3. **Handler** processes each message
4. On success, the message is acknowledged and removed from the queue
5. On error, the message is retried according to your retry strategy

## Configure retry behavior

Customize how failed messages are handled:

```rust
use broccoli_queue::queue::RetryStrategy;

let queue = BroccoliQueue::builder("redis://localhost:6379")
    .pool_connections(5)
    .failed_message_retry_strategy(
        RetryStrategy::new()
            .with_attempts(5)        // Retry up to 5 times
            .retry_failed(true)      // Enable retries
    )
    .build()
    .await?;
```

## Advanced message handling

For more control over success and error handling, use `process_messages_with_handlers`:

```rust
use broccoli_queue::{error::BroccoliError, queue::BroccoliQueue};

async fn process_job(message: BrokerMessage<JobPayload>) -> Result<(), BroccoliError> {
    println!("Processing job: {} ({})", message.payload.id, message.payload.task_name);
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    Ok(())
}

async fn on_success(message: BrokerMessage<JobPayload>, _result: ()) -> Result<(), BroccoliError> {
    println!("Successfully processed message: {:?}", message.task_id);
    Ok(())
}

async fn on_error(message: BrokerMessage<JobPayload>, err: BroccoliError) -> Result<(), BroccoliError> {
    eprintln!("Failed to process message {}: {}", message.payload.id, err);
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    queue
        .process_messages_with_handlers(
            "jobs",
            Some(5),     // 5 concurrent workers
            None,
            process_job,
            on_success,
            on_error,
        )
        .await?;

    Ok(())
}
```

## Publish options

Control message delivery with publish options:

```rust
use broccoli_queue::queue::PublishOptions;
use time::Duration;

// Publish with a 10-second delay
let options = PublishOptions {
    delay: Some(Duration::seconds(10)),
    priority: Some(1),  // Priority 1-5 (1 is highest)
    ttl: None,
    scheduled_at: None,
};

queue.publish_batch("jobs", None, jobs, Some(options)).await?;
```

<Note>
  Message scheduling requires enabling the `enable_scheduling` option when building the queue. For RabbitMQ, you'll also need the delayed-exchange plugin.
</Note>

## Using different brokers

<CodeGroup>

```rust Redis
let queue = BroccoliQueue::builder("redis://localhost:6379")
    .build()
    .await?;
```

```rust RabbitMQ
let queue = BroccoliQueue::builder("amqp://localhost:5672")
    .enable_scheduling(true)  // Requires delayed-exchange plugin
    .build()
    .await?;
```

```rust SurrealDB
let queue = BroccoliQueue::builder("ws://localhost:8000")
    .build()
    .await?;
```

</CodeGroup>

## Next steps

<CardGroup cols={2}>
  <Card
    title="API reference"
    icon="code"
    href="https://docs.rs/broccoli_queue"
  >
    Explore the complete API documentation
  </Card>
  <Card
    title="Examples"
    icon="github"
    href="https://github.com/densumesh/broccoli/tree/main/examples"
  >
    Browse more examples on GitHub
  </Card>
</CardGroup>
